// modified from: http://api.brain-map.org/examples/doc/lines/lines.js.html

// Copyright 2013 Allen Institute for Brain Science
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Visualize the spatial search density lines and injection site coordinates
// downloaded via download_data.py in 3D using threejs.

var dataFile = "data.json";

var mouseX = 0, mouseY = 0;
var targetRotationX = 0, targetRotationY = 0;
var targetRotationXOnMouseDown = 0, targetRotationYOnMouseDown = 0;

var mouseXOnMouseDown = 0, mouseYOnMouseDown = 0;

var container = null;

var maximum_number_of_lines = 600;
var scale = 0.01;
var dimensions = [ 133, 81, 115 ];

var camera, controls, scene, renderer, light;
var wallColor = [0xFFFF00, 0xFFCD70, 0xFF9E9B];
var redColor = 0xFF0000;
var greenColor = 0x02ff02;
var blueColor = 0x112dff;

var switchData = 0; // select which dataset to be shown
var switch000Sphere = 0; // show/hide 000-Sphere

// Kick things off.
initialize();

function createPartialSphere(dst_x, dst_y, dst_z, radii, range_theta_phi) {

  var r, th0, th1, ph0, ph1

	var num_wall = radii.length

	for (var i = 0; i < num_wall; i++) {
		r = radii[i]
		th0 = range_theta_phi[i][0][0]
		th1 = range_theta_phi[i][0][1]
		ph0 = range_theta_phi[i][1][0]
		ph1 = range_theta_phi[i][1][1]

		var sphere_geometry = new THREE.SphereGeometry(r*scale, 32, 32, ph0, ph1 - ph0, th0, th1 - th0);
		// var sphere_geometry = new THREE.SphereGeometry(r*scale, 32, 32, ph0, ph1, th0, th1);
		var sphere_material = new THREE.MeshLambertMaterial({color: wallColor[i], transparent: true, opacity: 0.8, side: THREE.DoubleSide});
		var sphere = new THREE.Mesh( sphere_geometry, sphere_material );

		// The coordinates are in microns.  World coordinates are in reference space voxel 100um coordinates.
		// Scale the coordinate accordingly and translate to the center of the reference space cube.
		sphere.position.x = dst_x;
		sphere.position.y = dst_y;
		sphere.position.z = dst_z;

		scene.add( sphere );
	}
}

function create000Sphere(r) {

		var sphere_geometry = new THREE.SphereGeometry(r*scale, 32, 32);
		var sphere_material = new THREE.MeshLambertMaterial({color: greenColor});
		var sphere = new THREE.Mesh( sphere_geometry, sphere_material );

		sphere.position.x = -dimensions[0] * 0.5;
		sphere.position.y = -dimensions[1] * 0.5;
		sphere.position.z = -dimensions[2] * 0.5;

		scene.add( sphere );

}

function initialize() {
	container = document.getElementById('chart');

	// If the browser supports WebGL, download the data and initialize the 3D components.
	// Otherwise, display an error.
	if ( Detector.webgl ) { // if browser supports WebGL
		$(container).append($("<div>").addClass("loading").html("Loading WebGL..."));

		download_data(function(data) {
			initialize_threejs(data);

			$(".loading").remove();
		});
	} else { // if browser doesn't supports WebGL
		$(container).append(
			$('<div>').addClass('svgError')
				.html("This demo requires WebGL support. " +
				  "Click <a href='http://caniuse.com/webgl'>here</a> " +
					  "to see which browsers support WebGL."));
	}
}

// Retrieve the data generated by download_data.py.  The number of downloaded lines can be a bit
// large for the browser, so some lines are filtered out.

function download_data(on_success) {
	$.ajax(dataFile, {
		dataType: "json",
		success: function(response) {

			var lines = response.lines;

			// If there are still too many lines, skip some.
			var stride = Math.round(lines.length / maximum_number_of_lines);
			if (stride > 1) {
				var out_lines = [];
				for (var i = 0; i < lines.length; i += stride) {
					out_lines.push(lines[i]);
				}
				response.lines = out_lines;
			}

			on_success(response);
		}
	});
}

// Initialize all of the components required by threejs once the data exists.

function initialize_threejs(data) {
	var lines = data.lines || [];
	var destination_coordinates = data.destinationCoordinates;
	var dst_x, dst_y, dst_z;
	var radii = data.wallRadii;
	var range_theta_phi = data.wallThetaPhi;
	var selected_indices0 = data.selected_indices0;
	var selected_indices1 = data.selected_indices1;
	var selected_indices2 = data.selected_indices2;
	var closest_points_idx = data.closest_points_idx;

	var jqcontainer = $(container);
	var width = jqcontainer.width();
	var height = jqcontainer.height();

	// Build the camera (field of view, aspect ratio, clipping planes, orientation, position).
	camera = new THREE.PerspectiveCamera( 33, width / height, 1, 10000 );
	camera.up.x = 0;
	camera.up.y = -1;
	camera.up.z = 0;
	camera.position.z = -300;

	// Initialize the mouse controls to allow pan/rotate/zoom.
	controls = new THREE.TrackballControls( camera, container );
	controls.rotateSpeed = 2.0;
	controls.zoomSpeed = 1.2;
	controls.panSpeed = 0.8;

	controls.noZoom = false;
	controls.noPan = false;

	controls.staticMoving = true;
	controls.dynamicDampingFactor = 0.3;

	controls.keys = [ 65, 83, 68 ];

	controls.addEventListener( 'change', render );

	// The scene will hold all of the lines and spheres.
	scene = new THREE.Scene();

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setClearColor(0x000000);
	renderer.setSize( width, height );

	// Don't forget to add the WebGL element to the DOM.
	container.appendChild( renderer.domElement );

	// This is a light that will track the camera position.
	light =	new THREE.PointLight(0xFFFFFF);
	scene.add(light);

	// Make the wireframe outline around the reference space.
	var wireframe_geometry = new THREE.CubeGeometry( dimensions[0],
													 dimensions[1],
													 dimensions[2] );

	var wireframe_material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF,
														   shading: THREE.FlatShading,
														   wireframe: true,
														   wireframeLinewidth: 1 } );

	var wireframe_cube = new THREE.Mesh( wireframe_geometry, wireframe_material );

	scene.add( wireframe_cube );

	// Add spheres to indicate destination site coordinates.
	for (var i = 0; i < destination_coordinates.length; i++) {
		var coord = destination_coordinates[i];

		var sphere_geometry = new THREE.SphereGeometry(200*scale, 8, 8);
		var sphere_material = new THREE.MeshLambertMaterial({ color: redColor });
		var sphere = new THREE.Mesh( sphere_geometry, sphere_material );

		// The coordinates are in microns.  World coordinates are in reference space voxel 100um coordinates.
		// Scale the coordinate accordingly and translate to the center of the reference space cube.
		sphere.position.x = coord[0]*scale - dimensions[0] * 0.5;
		sphere.position.y = coord[1]*scale - dimensions[1] * 0.5;
		sphere.position.z = coord[2]*scale - dimensions[2] * 0.5;

		dst_x = sphere.position.x
		dst_y = sphere.position.y
		dst_z = sphere.position.z

		scene.add( sphere );
	}

	// Add the lines now.
	for (var i = 0; i < lines.length; i++) {
		var path = lines[i].path;

		// Create a line strip for all of the path coordinates.
		var geometry = new THREE.Geometry();
		// Color the line by its injection structure color.
		// var colorint = parseInt(lines[i]['structure-color'], 16);
    var colorint = blueColor;

		if (!selected_indices0.includes(i)) { // paths that don't pass wall 0
    material = new THREE.LineBasicMaterial( { color: colorint, opacity: 1, linewidth: 1 } );

			for (var j = 0; j <= path.length-1; j++) {
				geometry.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
			}
		}else{ // paths that pass wall 0

			var geometry0 = new THREE.Geometry();
			material0 = new THREE.LineBasicMaterial( { color: wallColor[0], linewidth: 1 } );

			for (var j = 0; j <= closest_points_idx[i][0]; j++) {
				geometry0.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
			}

			var line0 = new THREE.Line(geometry0, material0 );
			line0.scale.x = line0.scale.y = line0.scale.z =  scale;
			line0.position.x = -dimensions[0] * 0.5;
			line0.position.y = -dimensions[1] * 0.5;
			line0.position.z = -dimensions[2] * 0.5;
			scene.add( line0 );

			if (!selected_indices1.includes(i)) { // passing wall 0 but NOT wall 1
        material = new THREE.LineBasicMaterial( { color: colorint, opacity: 1, linewidth: 1 } );
				for (var j = closest_points_idx[i][0]; j <= path.length-1; j++) {
					geometry.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
				}

			}else{ // passing wall 1

				var geometry1 = new THREE.Geometry();
				material1 = new THREE.LineBasicMaterial( { color: wallColor[1], linewidth: 1 } );

				for (var j = closest_points_idx[i][0]; j <= closest_points_idx[i][1]; j++) {
					geometry1.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
				}

				var line1 = new THREE.Line(geometry1, material1 );
				line1.scale.x = line1.scale.y = line1.scale.z =  scale;
				line1.position.x = -dimensions[0] * 0.5;
				line1.position.y = -dimensions[1] * 0.5;
				line1.position.z = -dimensions[2] * 0.5;
				scene.add( line1 );

					if (!selected_indices2.includes(i)) { // passing wall 1 but NOT wall 2
            material = new THREE.LineBasicMaterial( { color: colorint, opacity: 1, linewidth: 1 } );
						for (var j = closest_points_idx[i][1]; j <= path.length-1; j++) {
							geometry.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
						}

					}else{ // passing wall 2
            material = new THREE.LineBasicMaterial( { color: wallColor[2], opacity: 1, linewidth: 1 } );

						var geometry2 = new THREE.Geometry();
						material2 = new THREE.LineBasicMaterial( { color: wallColor[2], linewidth: 1 } );

						for (var j = closest_points_idx[i][1]; j <= closest_points_idx[i][2]; j++) {
							geometry2.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
						}

						var line2 = new THREE.Line(geometry2, material2 );
						line2.scale.x = line2.scale.y = line2.scale.z =  scale;
						line2.position.x = -dimensions[0] * 0.5;
						line2.position.y = -dimensions[1] * 0.5;
						line2.position.z = -dimensions[2] * 0.5;
						scene.add( line2 );

						for (var j = closest_points_idx[2][0] + 1; j <= path.length-1; j++) {
							geometry.vertices.push( new THREE.Vector3( path[j].coord[0], path[j].coord[1], path[j].coord[2] ) );
						}
					}
			}
		}

		// The coordinates are in microns, so set a global vertex position scale and then
		// translate to the center of the reference space.
		var line = new THREE.Line(geometry, material );
		line.scale.x = line.scale.y = line.scale.z =  scale;
		line.position.x = -dimensions[0] * 0.5;
		line.position.y = -dimensions[1] * 0.5;
		line.position.z = -dimensions[2] * 0.5;

		scene.add( line );
	}

	createPartialSphere(dst_x, dst_y, dst_z, radii, range_theta_phi);
  create000Sphere(200);

	animate();
}

// Enable touch panning/rotation.

function onDocumentTouchMove( event ) {

	if ( event.touches.length === 1 ) {

		event.preventDefault();

		var jqcontainer = $j(container);
		var hw = jqcontainer.width() / 2;
		var hh = jqcontainer.height() / 2;

		mouseX = event.touches[ 0 ].pageX - hw;
		mouseY = event.touches[ 0 ].pageY - hh;
		targetRotationX = targetRotationXOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
		targetRotationY = targetRotationYOnMouseDown + ( mouseY - mouseYOnMouseDown ) * 0.05;

	}

}

function animate() {
	requestAnimationFrame( animate );
	controls.update();
}

function render() {
	// no need to render if the camera position hasn't change.
	if (light.position.x != camera.position.x ||
		light.position.y != camera.position.y ||
		light.position.z != camera.position.z) {

		light.position.x = camera.position.x;
		light.position.y = camera.position.y;
		light.position.z = camera.position.z;

		renderer.render( scene, camera );
	}
}
